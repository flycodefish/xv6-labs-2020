1.哪些寄存器保存函数的参数？例如，在main对printf的调用中，哪个寄存器保存13？
在RISC-V架构中，函数参数保存在a0到a7寄存器中。查看调用printf的汇编源码：
可知13保存在a2寄存器中。

2.main的汇编代码中对函数f的调用在哪里？对g的调用在哪里(提示：编译器可能会将函数内联（inline））
没有调用f函数对应的汇编源码，因为g(x) 被内联到 f(x) 中，然后 f(x) 又被进一步内联到 main() 中。

3.printf函数位于哪个地址？
汇编源码对应部分：
auipc(Add Upper Immediate to PC)得到pc的值0x30存储在ra寄存器，jalr(jump and link register)指令跳转到ra寄存器的值并加上偏移量1536（即0x600），所以printf的地址是0x630

4.在main中printf的jalr之后的寄存器ra中有什么值？
auipc和jalr指令用于生成基于程序计数器（pc）的地址和跳转，用于计算相对地址。
auipc指令格式：auipc rd, imm。将20位的立即数imm左移12位后加上当前pc值，结果存入rd寄存器。rd = PC + (imm << 12)
jalr指令格式：jalr rd, offset(rs1) 。跳转到rs1寄存器中的地址加上偏移offset的位置，将跳转的下一条指令的地址存储在rd寄存器中。
回到printf汇编源码：
Asm
1
2
  30:	00000097          	auipc	ra,0x0
  34:	600080e7          	jalr	1536(ra) # 630 <printf>
第1行代码：对比指令格式，这行代码将0x0左移12位（还是0x0）加到pc（当前为0x30）并存入ra中，即ra中保存的是0x30
第2行代码：这对比jalr的标准格式有所不同，可能是此两处使用寄存器相同时，汇编中可以省略rd部分。ra中保存的是0x30，加上0x600后为0x630，即printf的地址，执行此行代码后，将跳转到printf函数执行，并将当前pc+4=0X34+0X4=0X38保存到ra中，供之后返回使用。

5.运行以下代码，程序的输出是什么？这是将字节映射到字符的ASCII码表。输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把i设置成什么？是否需要将57616更改为其他值？
C
运行代码
1
2
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
57616=0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表：72:r 6c:l 64:d 00:充当字符串结尾标识
因此输出为：HE110 World
若为大端存储，i应改为0x726c6400，不需改变57616

6.在下面的代码中，“y=”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？
C
运行代码
1
printf("x=%d y=%d", 3);
原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据。
